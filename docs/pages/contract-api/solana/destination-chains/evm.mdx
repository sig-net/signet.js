# EVM Destination Chain

This page documents how to use the `sign_bidirectional` instruction to execute transactions on EVM chains and receive execution results back on Solana.

For the general bidirectional flow, see [Sign Bidirectional Flow](/architecture/sign-bidirectional).

## Overview

When using an EVM chain as the destination from Solana:

1. Build an unsigned EVM transaction (RLP-encoded)
2. Call `sign_bidirectional` on Solana with the serialized transaction
3. Poll for `SignatureRespondedEvent` to get the signature
4. Assemble and broadcast the signed transaction to EVM
5. Poll for `RespondBidirectionalEvent` to get the execution result

## Transaction Encoding

EVM transactions must be RLP-encoded before passing to `sign_bidirectional`. The MPC signs the keccak256 hash of the unsigned transaction.

### EIP-1559 Transactions (Recommended)

```typescript
import { serializeTransaction, parseGwei, parseEther } from 'viem'

const unsignedTx = {
  type: 'eip1559',
  chainId: 1,
  nonce: 0,
  maxPriorityFeePerGas: parseGwei('1'),
  maxFeePerGas: parseGwei('20'),
  gas: 21000n,
  to: '0x...',
  value: parseEther('1'),
  data: '0x'
}

// Serialize to unsigned RLP (pass this to sign_bidirectional)
const serializedTx = serializeTransaction(unsignedTx)
// Result: 0x02... (EIP-1559 prefix + RLP body)
```

**What Gets Signed**:

```
Hash = keccak256(0x02 || RLP([chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data, accessList]))
```

### Legacy Transactions

```typescript
const legacyTx = {
  type: 'legacy',
  chainId: 1,
  nonce: 0,
  gasPrice: parseGwei('20'),
  gas: 21000n,
  to: '0x...',
  value: parseEther('1'),
  data: '0x'
}

const serializedTx = serializeTransaction(legacyTx)
```

**What Gets Signed**:

```
Hash = keccak256(RLP([nonce, gasPrice, gasLimit, to, value, data, chainId, 0, 0]))
```

## Calling sign_bidirectional

### Parameters for EVM Destination

| Parameter | Value for EVM |
|-----------|---------------|
| `serialized_transaction` | RLP-encoded unsigned transaction bytes |
| `caip2_id` | `"eip155:1"` (mainnet), `"eip155:11155111"` (Sepolia), etc. |
| `key_version` | MPC key version (typically `0`) |
| `path` | User derivation path (e.g., `""` or `"my_vault"`) |
| `algo` | `""` (default secp256k1) |
| `dest` | `"evm"` |
| `params` | `""` |
| `output_deserialization_schema` | ABI schema for parsing EVM return values |
| `respond_serialization_schema` | Borsh schema for response serialization |

### Example Call

```typescript
import { Program } from '@coral-xyz/anchor'

const serializedTx = Buffer.from(serializeTransaction(unsignedTx).slice(2), 'hex')

const outputSchema = JSON.stringify([
  { name: 'result', type: 'uint256' }
])
const respondSchema = JSON.stringify([
  { name: 'output', type: 'bytes' }
])

await program.methods
  .signBidirectional(
    serializedTx,                                    // serialized_transaction
    'eip155:1',                                      // caip2_id (Ethereum mainnet)
    0,                                               // key_version
    '',                                              // path
    '',                                              // algo
    'evm',                                           // dest
    '',                                              // params
    SystemProgram.programId,                         // program_id (reserved)
    Buffer.from(outputSchema),                       // output_deserialization_schema
    Buffer.from(respondSchema)                       // respond_serialization_schema
  )
  .accounts({
    programState: programStatePDA,
    requester: wallet.publicKey,
    feePayer: null,
    systemProgram: SystemProgram.programId,
    instructions: null
  })
  .signers([wallet])
  .rpc()
```

## Schemas

### Output Deserialization Schema (ABI Format)

Defines how to parse the EVM contract's return value. Uses Ethereum ABI type notation:

```typescript
// Contract returns: function foo() returns (uint256 result, bool success)
const outputSchema = JSON.stringify([
  { name: 'result', type: 'uint256' },
  { name: 'success', type: 'bool' }
])
```

**Supported ABI Types**:

| Type | Description |
|------|-------------|
| `uint256`, `uint128`, etc. | Unsigned integers |
| `int256`, `int128`, etc. | Signed integers |
| `bool` | Boolean |
| `address` | 20-byte address |
| `bytes32`, `bytes` | Fixed or dynamic bytes |
| `string` | Dynamic string |

### Respond Serialization Schema (Borsh Format)

Defines how to serialize the response for Solana:

```typescript
// Single output field containing the serialized result
const respondSchema = JSON.stringify([
  { name: 'output', type: 'bytes' }
])
```

## Handling the Signature

After `sign_bidirectional`, poll for `SignatureRespondedEvent`:

```typescript
// Parse signature from event
const signature = event.data.signature

// Convert to viem format
const r = '0x' + Buffer.from(signature.bigR.x).toString('hex')
const s = '0x' + Buffer.from(signature.s).toString('hex')
const v = 27n + BigInt(signature.recoveryId)

// Assemble signed transaction
const signedTx = serializeTransaction(unsignedTx, { r, s, v })
```

## Broadcasting to EVM

```typescript
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

const client = createPublicClient({
  chain: mainnet,
  transport: http()
})

const txHash = await client.sendRawTransaction({
  serializedTransaction: signedTx
})

console.log('EVM transaction hash:', txHash)
```

## Handling the Response

Poll for `RespondBidirectionalEvent` after the EVM transaction confirms:

```typescript
// Magic prefix indicating failed transaction
const MAGIC_ERROR_PREFIX = new Uint8Array([0xde, 0xad, 0xbe, 0xef])

function parseResponse(serializedOutput: Uint8Array) {
  // Check for failure
  if (
    serializedOutput.length >= 4 &&
    serializedOutput.slice(0, 4).every((b, i) => b === MAGIC_ERROR_PREFIX[i])
  ) {
    return {
      success: false,
      error: 'Transaction reverted on EVM'
    }
  }

  // Deserialize successful output using Borsh
  return {
    success: true,
    data: deserializeBorsh(serializedOutput, respondSchema)
  }
}

// Usage
const response = parseResponse(event.data.serializedOutput)
if (response.success) {
  console.log('Contract returned:', response.data)
} else {
  console.log('Transaction failed:', response.error)
}
```

## Verifying the Response Signature

The response is signed by the MPC using the derivation path `"solana response key"`. Verify on-chain or client-side:

```typescript
import { keccak256, concat, recoverPublicKey, toHex } from 'viem'

// Compute message hash (what was signed)
const messageHash = keccak256(
  concat([requestId, serializedOutput])
)

// Recover public key
const recoveredPubKey = recoverPublicKey({
  hash: messageHash,
  signature: {
    r: toHex(signature.bigR.x),
    s: toHex(signature.s),
    v: 27n + BigInt(signature.recoveryId)
  }
})

// Compare with expected MPC response public key
```

## Complete Example

```typescript
import {
  serializeTransaction,
  parseGwei,
  createPublicClient,
  http,
  encodeFunctionData,
  toHex
} from 'viem'
import { mainnet } from 'viem/chains'
import { Program } from '@coral-xyz/anchor'

// 1. Derive EVM address for Solana user
const { address: fromAddress } = await evmChain.deriveAddressAndPublicKey(
  wallet.publicKey.toString(),
  '',  // derivation path
  0    // key version
)

// 2. Create EVM public client
const evmClient = createPublicClient({
  chain: mainnet,
  transport: http()
})

// 3. Build unsigned EVM transaction
const unsignedTx = {
  type: 'eip1559' as const,
  chainId: 1,
  nonce: await evmClient.getTransactionCount({ address: fromAddress }),
  maxPriorityFeePerGas: parseGwei('1'),
  maxFeePerGas: parseGwei('20'),
  gas: 100000n,
  to: contractAddress,
  value: 0n,
  data: encodeFunctionData({
    abi: contractAbi,
    functionName: 'myFunction',
    args: [arg1, arg2]
  })
}

// 4. Serialize for signing
const serializedTx = Buffer.from(
  serializeTransaction(unsignedTx).slice(2),
  'hex'
)

// 5. Define schemas
const outputSchema = JSON.stringify([
  { name: 'result', type: 'uint256' }
])
const respondSchema = JSON.stringify([
  { name: 'output', type: 'bytes' }
])

// 6. Call sign_bidirectional
const tx = await program.methods
  .signBidirectional(
    serializedTx,
    'eip155:1',
    0,
    '',
    '',
    'evm',
    '',
    SystemProgram.programId,
    Buffer.from(outputSchema),
    Buffer.from(respondSchema)
  )
  .accounts({
    programState: programStatePDA,
    requester: wallet.publicKey,
    feePayer: null,
    systemProgram: SystemProgram.programId,
    instructions: null
  })
  .signers([wallet])
  .rpc()

// 7. Poll for signature
const signatureEvent = await pollForSignatureRespondedEvent(requestId)
const { bigR, s, recoveryId } = signatureEvent.signature

// 8. Assemble and broadcast to EVM
const r = toHex(bigR.x, { size: 32 })
const sHex = toHex(s, { size: 32 })
const v = 27n + BigInt(recoveryId)

const signedTx = serializeTransaction(unsignedTx, { r, s: sHex, v })
const evmTxHash = await evmClient.sendRawTransaction({
  serializedTransaction: signedTx
})

console.log('EVM tx broadcast:', evmTxHash)

// 9. Poll for bidirectional response
const responseEvent = await pollForRespondBidirectionalEvent(requestId)

// 10. Parse result
const MAGIC_ERROR = new Uint8Array([0xde, 0xad, 0xbe, 0xef])
const output = new Uint8Array(responseEvent.serializedOutput)

if (output.slice(0, 4).every((b, i) => b === MAGIC_ERROR[i])) {
  console.log('EVM transaction reverted')
} else {
  console.log('EVM execution result:', output)
}
```

## CAIP-2 Chain Identifiers

| Chain | CAIP-2 ID |
|-------|-----------|
| Ethereum Mainnet | `eip155:1` |
| Sepolia | `eip155:11155111` |
| Arbitrum One | `eip155:42161` |
| Optimism | `eip155:10` |
| Base | `eip155:8453` |
| Polygon | `eip155:137` |

## Light Client Observation

The MPC uses [Helios](https://github.com/a16z/helios) to observe EVM chains:

| Feature | Purpose |
|---------|---------|
| Consensus sync | Validates beacon chain headers |
| Execution proofs | Verifies state without full node |
| `eth_getBlockReceipts` | Gets transaction receipts for status |
| `eth_call` | Simulates calls to extract return data |

The MPC monitors each block for pending bidirectional transactions and extracts execution results when found.

## Related Documentation

- [sign_bidirectional Instruction](/contract-api/solana/instructions#sign_bidirectional) - Instruction reference
- [Events](/contract-api/solana/events) - Event structures
- [Sign Bidirectional Flow](/architecture/sign-bidirectional) - Architecture overview
